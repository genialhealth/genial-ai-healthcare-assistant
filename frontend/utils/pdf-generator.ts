import jsPDF from 'jspdf';
import { MedicalReport } from '@/types';

interface ReportContent {
  patient_summary: string;
  clinical_summary: string;
}

interface FullReportData {
  content: ReportContent;
  structured_data: MedicalReport;
  images_base64: Record<string, string>;
}

export const generateMedicalReportPDF = (data: FullReportData) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  let yPos = margin;

  const navy = [11, 31, 58];
  const gray = [100, 100, 100];
  const lightGray = [150, 150, 150];

  const checkPageBreak = (heightNeeded: number) => {
    if (yPos + heightNeeded > pageHeight - margin) {
      doc.addPage();
      yPos = margin;
      return true;
    }
    return false;
  };

  const drawHeader = (title: string) => {
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(18);
    doc.setTextColor(navy[0], navy[1], navy[2]);
    doc.text(title, margin, yPos);
    yPos += 10;
    
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.5);
    doc.line(margin, yPos, pageWidth - margin, yPos);
    yPos += 10;
  };

  const drawFooter = () => {
    const totalPages = doc.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(lightGray[0], lightGray[1], lightGray[2]);
      doc.text(
        `Generated by Genial Team Assistant - Page ${i} of ${totalPages}`, 
        pageWidth / 2, 
        pageHeight - 10, 
        { align: 'center' }
      );
      doc.text(
        "Disclaimer: This report is AI-generated for informational purposes only and does not constitute a medical diagnosis.",
        pageWidth / 2,
        pageHeight - 5,
        { align: 'center' }
      );
    }
  };

  // --- Page 1: Patient Summary ---
  
  // Title
  doc.setFontSize(24);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(navy[0], navy[1], navy[2]);
  doc.text("Genial Medical Report", pageWidth / 2, yPos + 10, { align: 'center' });
  
  yPos += 25;
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(gray[0], gray[1], gray[2]);
  doc.text(`Date: ${new Date().toLocaleDateString()}`, pageWidth / 2, yPos, { align: 'center' });
  
  yPos += 20;
  
  drawHeader("Patient Summary");

  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(0, 0, 0);
  const patientSummaryLines = doc.splitTextToSize(data.content.patient_summary, pageWidth - 2 * margin);
  doc.text(patientSummaryLines, margin, yPos);
  yPos += patientSummaryLines.length * 6 + 10;

  // --- Page 2: Clinical Report ---
  doc.addPage();
  yPos = margin;
  drawHeader("Clinical Report (Physician Copy)");

  // Clinical Narrative
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(navy[0], navy[1], navy[2]);
  doc.text("Clinical Narrative", margin, yPos);
  yPos += 8;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(0, 0, 0);
  const clinicalSummaryLines = doc.splitTextToSize(data.content.clinical_summary, pageWidth - 2 * margin);
  doc.text(clinicalSummaryLines, margin, yPos);
  yPos += clinicalSummaryLines.length * 5 + 15;

  // Structured Evidence
  checkPageBreak(60);
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(navy[0], navy[1], navy[2]);
  doc.text("Clinical Evidence & Symptoms", margin, yPos);
  yPos += 8;

  const evidences = data.structured_data.evidences;
  if (Object.keys(evidences).length > 0) {
    Object.entries(evidences).forEach(([key, value]) => {
      doc.setFontSize(10);
      
      // Calculate wrapped lines for both label and value first to determine row height
      doc.setFont('helvetica', 'bold');
      const keyLines = doc.splitTextToSize(`${key}:`, 35);
      
      doc.setFont('helvetica', 'normal');
      const valueLines = doc.splitTextToSize(String(value), pageWidth - margin - 60);
      
      const maxLines = Math.max(keyLines.length, valueLines.length);
      const rowHeight = maxLines * 5 + 2;
      
      checkPageBreak(rowHeight);
      
      // Render label
      doc.setFont('helvetica', 'bold');
      doc.text(keyLines, margin, yPos);
      
      // Render value
      doc.setFont('helvetica', 'normal');
      doc.text(valueLines, margin + 40, yPos);
      
      yPos += rowHeight + 2; // Extra spacing between items
    });
  } else {
    doc.setFont('helvetica', 'italic');
    doc.text("No specific evidence recorded.", margin, yPos);
    yPos += 10;
  }
  
  yPos += 10;

  // Differential Diagnosis
  checkPageBreak(60);
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(navy[0], navy[1], navy[2]);
  doc.text("Differential Diagnosis", margin, yPos);
  yPos += 8;

  const diseases = data.structured_data.most_likely_disease;
  if (diseases && diseases.length > 0) {
    diseases.forEach((d) => {
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      const nameLines = doc.splitTextToSize(d.name, pageWidth - 2 * margin);
      
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      const reasonLines = doc.splitTextToSize(d.reason, pageWidth - 2 * margin);
      
      const itemHeight = (nameLines.length * 5) + (reasonLines.length * 4) + 6;
      checkPageBreak(itemHeight);
      
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.text(nameLines, margin, yPos);
      yPos += nameLines.length * 5;
      
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.text(reasonLines, margin, yPos);
      yPos += reasonLines.length * 4 + 6;
    });
  } else {
    doc.setFont('helvetica', 'italic');
    doc.text("No specific conditions identified.", margin, yPos);
    yPos += 10;
  }

  // --- Page 3+: Images & Analysis ---
  const images = data.structured_data.images;
  const analyses = data.structured_data.images_analyses;
  const imagesB64 = data.images_base64 || {};
  
  if (Object.keys(images).length > 0) {
    doc.addPage();
    yPos = margin;
    drawHeader("Visual Findings & Analysis");

    for (const [title, filename] of Object.entries(images)) {
      const analysis = analyses[title] || "No analysis available.";
      
      // Calculate height needed: text + image + spacing
      checkPageBreak(120); 

      // Title
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(navy[0], navy[1], navy[2]);
      doc.text(`Image Reference: ${title}`, margin, yPos);
      yPos += 7;

      // Image
      // We look up the base64 string directly from the backend payload using the title
      const base64Img = imagesB64[title];
      
      if (base64Img) {
        let finalWidth = 80;
        let finalHeight = 60;
        
        // Detect format from base64 header
        let format = 'JPEG';
        if (base64Img.startsWith('data:image/png')) {
            format = 'PNG';
        } else if (base64Img.startsWith('data:image/webp')) {
             format = 'JPEG'; 
        }

        try {
            const props = doc.getImageProperties(base64Img);
            const ratio = props.width / props.height;
            const maxWidth = 80;
            const maxHeight = 80; // Allow a bit more height if needed
            
            finalWidth = maxWidth;
            finalHeight = finalWidth / ratio;
            
            if (finalHeight > maxHeight) {
                finalHeight = maxHeight;
                finalWidth = finalHeight * ratio;
            }
            
            doc.addImage(base64Img, format, margin, yPos, finalWidth, finalHeight);
        } catch (e) {
            console.error("PDF Image Error:", e);
            doc.text("[Image format not supported]", margin, yPos + 10);
            finalWidth = 80;
            finalHeight = 20;
        }
        
        const startBlockY = yPos;

        // Render Analysis text with basic Markdown formatting
        doc.setFontSize(10);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(0, 0, 0);
        doc.text("Medical Analysis:", margin + finalWidth + 10, yPos + 5);
        yPos += 12;

        const maxWidth = pageWidth - (margin + finalWidth + 10 + margin);
        const startX = margin + finalWidth + 10;
        
        const lines = analysis.split('\n');
        
        lines.forEach(line => {
            line = line.trim();
            if (!line) {
                yPos += 3; // Small gap for empty lines
                return;
            }

            let isHeader = false;
            let isList = false;
            let textToPrint = line;

            // Detect Headers (### or **Title**)
            if (line.startsWith('#')) {
                isHeader = true;
                textToPrint = line.replace(/^#+\s*/, '');
            } else if (line.startsWith('**') && line.endsWith('**') && line.length < 50) {
                isHeader = true;
                textToPrint = line.replace(/\*\*/g, '');
            } else if (line.startsWith('**') && line.includes(':')) {
                 textToPrint = line.replace(/\*\*/g, '');
            }

            // Detect Lists
            if (line.startsWith('- ') || line.startsWith('* ')) {
                isList = true;
                textToPrint = line.substring(2);
            }

            // Apply Styles
            if (isHeader) {
                doc.setFont('helvetica', 'bold');
                yPos += 2; // Extra space before header
            } else {
                doc.setFont('helvetica', 'normal');
            }

            // Clean inline bold markers
            textToPrint = textToPrint.replace(/\*\*/g, '');

            // Handle Word Wrap
            const wrappedLines = doc.splitTextToSize(textToPrint, maxWidth - (isList ? 5 : 0));
            
            wrappedLines.forEach((wrappedLine: string) => {
                doc.text(wrappedLine, startX + (isList ? 5 : 0), yPos);
                yPos += 5; // Line height
            });
            
            if (isHeader) {
                yPos += 2; // Extra space after header
            }
        });
        
        // Ensure yPos moves down enough for the next item
        yPos = Math.max(yPos, startBlockY + finalHeight) + 15;
      } else {
        doc.setFont('helvetica', 'italic');
        doc.setTextColor(gray[0], gray[1], gray[2]);
        doc.text("[Image could not be loaded]", margin, yPos);
        yPos += 10;
        
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal'); // Ensure normal font here too
        doc.setTextColor(0, 0, 0);
        const analysisLines = doc.splitTextToSize(analysis, pageWidth - 2 * margin);
        doc.text(analysisLines, margin, yPos);
        yPos += analysisLines.length * 5 + 15;
      }
    }
  }

  drawFooter();
  doc.save('Genial_Professional_Report.pdf');
};
